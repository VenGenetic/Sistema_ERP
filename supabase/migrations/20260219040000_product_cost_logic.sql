-- Migration: Product Cost Logic (Three Strikes System)
-- Description: Adds cost tracking and history to products table.

-- 1. Modificar la tabla products para soportar el sistema de strikes y costos
ALTER TABLE products
ADD COLUMN IF NOT EXISTS cost_without_vat NUMERIC(10,4) DEFAULT 0, -- Costo oficial actual
ADD COLUMN IF NOT EXISTS vat_percentage NUMERIC(5,2) DEFAULT 12.0, -- Por defecto 12% (o lo que aplique)
ADD COLUMN IF NOT EXISTS strike_price_candidate NUMERIC(10,4) DEFAULT NULL, -- El precio que "intenta" ser el nuevo oficial
ADD COLUMN IF NOT EXISTS strike_count INT DEFAULT 0; -- Contador de strikes (0 a 3)

-- 2. Crear una tabla historial de entradas para auditoría de precios (Opcional pero recomendado)
CREATE TABLE IF NOT EXISTS product_entries_history (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    product_id BIGINT REFERENCES products(id),
    sku TEXT,
    cost_without_vat NUMERIC(10,4) NOT NULL,
    discounted_cost NUMERIC(10,4), -- Puede ser NULL
    discount_percentage NUMERIC(5,2), -- Calculado
    vat_percentage NUMERIC(5,2) NOT NULL,
    final_cost_with_vat NUMERIC(10,4) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    user_id UUID REFERENCES auth.users(id)
);

-- Enable RLS for history
ALTER TABLE product_entries_history ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow read access for authenticated users" ON product_entries_history FOR SELECT TO authenticated USING (true);
CREATE POLICY "Allow insert access for authenticated users" ON product_entries_history FOR INSERT TO authenticated WITH CHECK (true);


-- 3. Function to process cost entry
CREATE OR REPLACE FUNCTION process_product_entry_cost(
    p_product_id BIGINT,
    p_cost_without_vat NUMERIC,
    p_discounted_cost NUMERIC, -- Puede ser NULL
    p_vat_percentage NUMERIC,
    p_user_id UUID
)
RETURNS JSON
LANGUAGE plpgsql
AS $$
DECLARE
    v_current_official_cost NUMERIC;
    v_strike_candidate NUMERIC;
    v_strike_count INT;
    v_final_cost_to_store NUMERIC;
    v_discount_pct NUMERIC;
    v_cost_with_iva NUMERIC;
    v_message TEXT;
BEGIN
    -- 1. Obtener datos actuales del producto
    SELECT 
        cost_without_vat, strike_price_candidate, strike_count 
    INTO 
        v_current_official_cost, v_strike_candidate, v_strike_count
    FROM products
    WHERE id = p_product_id;

    -- Definir qué costo usamos para la lógica (si hay descuento, usamos ese, sino el normal)
    v_final_cost_to_store := COALESCE(p_discounted_cost, p_cost_without_vat);
    
    -- Cálculos de propiedades derivadas (para guardar en historial)
    IF p_discounted_cost IS NOT NULL AND p_cost_without_vat > 0 THEN
        v_discount_pct := ROUND((1 - (p_discounted_cost / p_cost_without_vat)) * 100, 2);
    ELSE
        v_discount_pct := 0;
    END IF;

    v_cost_with_iva := v_final_cost_to_store * (1 + (p_vat_percentage / 100));

    -- LÓGICA DE STRIKES
    
    -- Caso A: Es el primer costo registrado nunca
    IF v_current_official_cost IS NULL OR v_current_official_cost = 0 THEN
        UPDATE products 
        SET cost_without_vat = v_final_cost_to_store,
            vat_percentage = p_vat_percentage,
            strike_count = 0,
            strike_price_candidate = NULL
        WHERE id = p_product_id;
        v_message := 'Costo inicial establecido.';

    -- Caso B: El nuevo costo COINCIDE con el oficial
    ELSIF v_final_cost_to_store = v_current_official_cost THEN
        -- Reseteamos strikes porque el precio se mantiene estable
        UPDATE products 
        SET strike_count = 0,
            strike_price_candidate = NULL
        WHERE id = p_product_id;
        v_message := 'Precio coincide. Strikes reseteados.';

    -- Caso C: El nuevo costo NO coincide (Posible cambio de precio)
    ELSE
        -- ¿Coincide con el candidato a strike anterior?
        IF v_final_cost_to_store = v_strike_candidate THEN
            -- Aumentamos strike
            IF v_strike_count + 1 >= 3 THEN
                -- 3 Strikes alcanzados: Actualizamos el precio oficial
                UPDATE products 
                SET cost_without_vat = v_final_cost_to_store,
                    vat_percentage = p_vat_percentage,
                    strike_count = 0,
                    strike_price_candidate = NULL
                WHERE id = p_product_id;
                v_message := 'Precio actualizado oficialmente (3 Strikes alcanzados).';
            ELSE
                -- Aumentamos contador
                UPDATE products 
                SET strike_count = strike_count + 1
                WHERE id = p_product_id;
                v_message := 'Strike ' || (v_strike_count + 1) || ' agregado.';
            END IF;
        ELSE
            -- El precio es diferente al oficial Y diferente al ultimo candidato
            -- Nuevo candidato, primer strike
            UPDATE products 
            SET strike_price_candidate = v_final_cost_to_store,
                strike_count = 1
            WHERE id = p_product_id;
            v_message := 'Nuevo precio detectado. Strike 1 generado.';
        END IF;
    END IF;

    -- 2. Insertar en historial (Auditoría)
    INSERT INTO product_entries_history (
        product_id, sku, cost_without_vat, discounted_cost, 
        discount_percentage, vat_percentage, final_cost_with_vat, user_id
    ) VALUES (
        p_product_id, (SELECT sku FROM products WHERE id = p_product_id), 
        p_cost_without_vat, p_discounted_cost, 
        v_discount_pct, p_vat_percentage, v_cost_with_iva, p_user_id
    );

    RETURN json_build_object(
        'success', true,
        'message', v_message,
        'new_official_cost', v_final_cost_to_store
    );
END;
$$;
